
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tic Tac Toe — Sam vs Sup (Online)</title>

  <style>
    :root{
      --cell-size: clamp(84px, 22vw, 140px);
      --gap: 12px;
      --border: rgba(255,255,255,.25);
      --glass-strong: rgba(255,255,255,.08);
      --text: #fff;
      --muted: #d0d0d0;
      --shadow-soft: 0 10px 24px rgba(0,0,0,.25);
      --a-fast: .18s ease;
    }
    body{ margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:#0e1117; color:#fff; }
    .page{ max-width: 900px; margin: 24px auto; padding: 0 16px; }
    .title{ margin: 8px 0 16px; text-align:center; }

    /* Players */
    .players-wrap{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; margin-bottom: 12px; }
    .player-card{ position:relative; display:flex; gap:12px; padding:10px; border-radius:16px;
      border:1px solid var(--border); background: rgba(255,255,255,.06); align-items:center; }
    .player-card.active{ outline:2px solid #34d399; }
    .player-card.winner{ outline:2px solid #60a5fa; }
    .photo{ width:64px; height:64px; border-radius:12px; overflow:hidden; display:grid; place-items:center;
      background:#1f2937; border:1px solid var(--border); cursor:pointer; }
    .photo img{ width:100%; height:100%; object-fit:cover; display:none; }
    .ph{ color:#bbb; font-size:.8rem; text-align:center; padding:6px; }
    .meta .name{ font-weight:700; font-size:1.1rem; }
    .meta .tag{ color:#bbb; margin-top:2px; }
    .meta .score{ margin-top:6px; }

    /* Status */
    .status{ text-align:center; margin: 10px 0 16px; }

    /* Board */
    .board{ display:grid; grid-template-columns: repeat(3, var(--cell-size));
      grid-template-rows: repeat(3, var(--cell-size));
      gap: var(--gap); margin: 0 auto 16px; width: max-content; }
    .cell{ display:grid; place-items:center; font-weight:900; font-size: clamp(2rem, 7vw, 4rem);
      border-radius:16px; border:1px solid var(--border); background: rgba(255,255,255,.06); cursor:pointer;
      transition: transform var(--a-fast), background var(--a-fast), box-shadow var(--a-fast), border-color var(--a-fast);
      user-select:none; }
    .cell:hover{ background: rgba(255,255,255,.12); transform: translateY(-1px); box-shadow: var(--shadow-soft); }
    .cell.win{ background: rgba(96,165,250,.18); border-color: rgba(96,165,250,.45); }

    /* Center the control buttons under the board */
    .controls{
      display: flex; gap: 10px; flex-wrap: wrap;
      justify-content: center;
      margin: 0 auto;
      width: max-content;
      min-width: calc(3 * var(--cell-size) + 2 * var(--gap));
      max-width: 100%;
    }
    .btn{
      padding:9px 14px; border-radius:12px; border:1px solid var(--border);
      background:var(--glass-strong); color:var(--text); cursor:pointer; backdrop-filter:blur(6px);
      transition:transform var(--a-fast), background var(--a-fast), box-shadow var(--a-fast), border-color var(--a-fast);
    }
    .btn:hover{ background:rgba(255,255,255,.14); transform:translateY(-1px); box-shadow:var(--shadow-soft); }
    .btn:active{ transform:translateY(0); }
    .btn.secondary{ color:var(--muted); }

    /* Room bar */
    .room-bar{ display:flex; gap:8px; justify-content:center; align-items:center; margin: 12px 0 18px; }
    .room-id{ font-family: ui-monospace, Menlo, Consolas, monospace; padding:6px 10px; border-radius:8px;
      background:#111827; border:1px solid var(--border); }
    .room-actions{ display:flex; gap:8px; }

    /* Fullscreen win video overlay (same as your original) */
    .video-overlay{ position:fixed; inset:0; background:#000; display:none; place-items:center; z-index:9999; }
    .video-overlay.show{ display:grid; }
    .video-overlay video{
      width: 100vw; height: 100vh; object-fit: contain; object-position: center; outline: none; background: #000;
      transform: none;
    }
    .winner-banner{
      position:fixed; top:12%; left:50%; transform:translateX(-50%);
      padding:18px 26px; background:rgba(0,0,0,.45); color:#fff; font-weight:800;
      font-size:clamp(1.4rem,3vw,2.2rem); border-radius:16px; border:1px solid rgba(255,255,255,.2);
      backdrop-filter:blur(10px); box-shadow:0 10px 30px rgba(0,0,0,.35); text-align:center; pointer-events:none;
    }
    .skip-btn{
      position:fixed; top:16px; right:16px; z-index:10000; padding:8px 12px;
      border-radius:12px; border:1px solid rgba(255,255,255,.25); background:rgba(0,0,0,.45);
      color:#fff; cursor:pointer; backdrop-filter:blur(6px); transition:transform var(--a-fast), background var(--a-fast);
    }
    .skip-btn:hover{ background:rgba(0,0,0,.65); transform:translateY(-1px); }

    #winVideo::-webkit-media-controls { display:none !important; }
    #winVideo { outline:none; }

    @media (min-width: 1200px) {
      .page { max-width: 1200px; }
      :root { --cell-size: clamp(120px, 22vw, 180px); }
    }
  </style>
</head>
<body>
  <div class="page">
    <h1 class="title">Tic Tac Toe — Sam vs Sup (Online)</h1>

    <!-- Simple room join/create bar -->
    <div class="room-bar">
      <input id="roomInput" class="room-id" placeholder="Room ID (e.g., sam-sup-1)" />
      <div class="room-actions">
        <button id="btnCreateRoom" class="btn" type="button">Create Room</button>
        <button id="btnJoinRoom" class="btn" type="button">Join Room</button>
        <button id="btnCopyLink" class="btn secondary" type="button">Copy Invite Link</button>
      </div>
    </div>

    <!-- Players -->
    <div class="players-wrap">
      <div class="player-card" id="playerX">
        <div class="photo" id="photoX" title="Click to choose photo">
          <img id="imgX" alt="Sam" />
          <div class="ph" id="phX">Click to set photo</div>
          <input id="fileX" type="file" accept=".jpg,.jpeg,.png,.JPG,.JPEG,.PNG" hidden />
        </div>
        <div class="meta">
          <div class="name">Sam</div>
          <div class="tag">Plays: <span class="symbol">X</span></div>
          <div class="score">Score: <span id="scoreX">0</span></div>
        </div>
        <div class="turn-indicator" aria-label="turn"></div>
      </div>

      <div class="player-card" id="playerO">
        <div class="photo" id="photoO" title="Click to choose photo">
          <img id="imgO" alt="Sup" />
          <div class="ph" id="phO">Click to set photo</div>
          <input id="fileO" type="file" accept=".jpg,.jpeg,.png,.JPG,.JPEG,.PNG" hidden />
        </div>
        <div class="meta">
          <div class="name">Sup</div>
          <div class="tag">Plays: <span class="symbol">O</span></div>
          <div class="score">Score: <span id="scoreO">0</span></div>
        </div>
        <div class="turn-indicator" aria-label="turn"></div>
      </div>
    </div>

    <!-- Status -->
    <div id="statusBar" class="status" role="status" aria-live="polite">Your turn: X (Sam)</div>

    <!-- Board -->
    <div id="board" class="board" aria-label="Tic Tac Toe board">
      <div class="cell" data-idx="0"></div>
      <div class="cell" data-idx="1"></div>
      <div class="cell" data-idx="2"></div>
      <div class="cell" data-idx="3"></div>
      <div class="cell" data-idx="4"></div>
      <div class="cell" data-idx="5"></div>
      <div class="cell" data-idx="6"></div>
      <div class="cell" data-idx="7"></div>
      <div class="cell" data-idx="8"></div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button id="btnReset" class="btn" type="button">Reset Scores</button>
      <button id="btnAgain" class="btn" type="button">Play Again</button>
      <button id="btnSwap"  class="btn secondary" type="button">Swap Starter</button>
    </div>
  </div>

  <!-- Win video overlay -->
  <div id="videoOverlay" class="video-overlay" aria-hidden="true">
    <video id="winVideo" preload="auto" playsinline muted></video>
    <div id="winnerBanner" class="winner-banner" aria-live="polite"></div>
    <button id="skipVideo" class="skip-btn" type="button" aria-label="Skip video">Skip ⨯</button>
  </div>

  <!-- Firebase + Multiplayer logic -->
  <script type="module">
    /***** Firebase SDKs via <script> tag (modular) *****/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, runTransaction
    } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

    // ---- Replace with your actual config from Firebase Console
    const firebaseConfig = {
      apiKey: "YOUR-API-KEY",
      authDomain: "YOUR-PROJECT.firebaseapp.com",
      projectId: "YOUR-PROJECT-ID",
      storageBucket: "YOUR-PROJECT.appspot.com",
      messagingSenderId: "XXXX",
      appId: "XXXX"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    /***** Original Local Game + UI *****/
    let board = Array(9).fill(null);
    let current = 'X';
    let xStarts = true;
    let gameOver = false;
    let scoreX = 0, scoreO = 0;

    const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];

    const cells = Array.from(document.querySelectorAll('.cell'));
    const statusBar = document.getElementById('statusBar');
    const btnReset = document.getElementById('btnReset');
    const btnAgain = document.getElementById('btnAgain');
    const btnSwap  = document.getElementById('btnSwap');

    const players = {
      X: { name:'Sam',
        imgEl:document.getElementById('imgX'), phEl:document.getElementById('phX'),
        fileEl:document.getElementById('fileX'), photoBox:document.getElementById('photoX'),
        cardEl:document.getElementById('playerX'), scoreEl:document.getElementById('scoreX')
      },
      O: { name:'Sup',
        imgEl:document.getElementById('imgO'), phEl:document.getElementById('phO'),
        fileEl:document.getElementById('fileO'), photoBox:document.getElementById('photoO'),
        cardEl:document.getElementById('playerO'), scoreEl:document.getElementById('scoreO')
      }
    };

    const videoOverlay  = document.getElementById('videoOverlay');
    const winVideo      = document.getElementById('winVideo');
    const skipBtn       = document.getElementById('skipVideo');
    const winnerBanner  = document.getElementById('winnerBanner');
    const once = (t,e)=>new Promise(r=>t.addEventListener(e,r,{once:true}));
    const WIN_SRC = './win.mp4'; // keep win.mp4 next to index.html

    function showImg(p, url){ p.imgEl.src = url; p.imgEl.style.display='block'; p.phEl.style.display='none'; }
    function showPlaceholder(p, text){ p.imgEl.style.display='none'; p.phEl.style.display='grid'; p.phEl.textContent = text || 'Click to set photo'; }
    function savePhoto(key, dataURL){ try{ localStorage.setItem(key, dataURL) }catch{} }
    function loadPhoto(key){ try{ return localStorage.getItem(key) }catch{ return null } }
    function probe(url){ return new Promise(res=>{ const i=new Image(); i.onload=()=>res(true); i.onerror=()=>res(false); i.src=url+'?v='+(Date.now()); }); }

    async function initPhoto(p, baseName, storageKey){
      const saved = loadPhoto(storageKey);
      if (saved){ showImg(p, saved); return; }
      const candidates = [`./${baseName}.jpg`,`./${baseName}.jpeg`,`./${baseName}.png`,`./${baseName}.JPG`,`./${baseName}.JPEG`,`./${baseName}.PNG`];
      for (const c of candidates){ if (await probe(c)){ showImg(p, c); return; } }
      showPlaceholder(p);
    }
    function hookPhotoPicker(p, storageKey){
      p.photoBox.addEventListener('click', () => p.fileEl.click());
      p.fileEl.addEventListener('change', ()=>{
        const f = p.fileEl.files && p.fileEl.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = ()=>{ const dataURL = reader.result; showImg(p, dataURL); savePhoto(storageKey, dataURL); };
        reader.readAsDataURL(f);
      });
      p.imgEl.addEventListener('error', ()=> showPlaceholder(p, 'Click to set photo'));
    }
    hookPhotoPicker(players.X, 'photoX');
    hookPhotoPicker(players.O, 'photoO');
    initPhoto(players.X, 'sam', 'photoX');
    initPhoto(players.O, 'sup', 'photoO');

    function updateStatus(text){ statusBar.textContent = text; }
    function updateTurnUI(){
      players.X.cardEl.classList.remove('active','winner');
      players.O.cardEl.classList.remove('active','winner');
      (current==='X'?players.X.cardEl:players.O.cardEl).classList.add('active');
      players.X.scoreEl.textContent = String(scoreX);
      players.O.scoreEl.textContent = String(scoreO);
    }
    function render(){ cells.forEach((c,i)=>{ c.textContent = board[i] || ''; c.classList.remove('win'); }); }

    function checkWinner(){
      for(const line of wins){
        const [a,b,c]=line;
        if(board[a] && board[a]===board[b] && board[a]===board[c]){
          line.forEach(idx=>cells[idx].classList.add('win')); return board[a];
        }
      }
      if(board.every(x=>x)) return 'Draw';
      return null;
    }
    function nextTurn(){
      current = (current==='X') ? 'O' : 'X';
      updateStatus(`Your turn: ${current} (${players[current].name})`);
      updateTurnUI();
    }
    function onResult(res){
      gameOver = true;
      if(res==='X'){ scoreX++; players.X.cardEl.classList.add('winner'); updateStatus(`X wins! (${players.X.name})`); playWinVideo('X'); }
      else if(res==='O'){ scoreO++; players.O.cardEl.classList.add('winner'); updateStatus(`O wins! (${players.O.name})`); playWinVideo('O'); }
      else { updateStatus(`It’s a draw!`); }
      updateTurnUI();
    }
    function handleMoveLocal(idx){
      if (gameOver || board[idx]) return;
      board[idx] = current;
      cells[idx].textContent = current;
      const res = checkWinner();
      if (res) onResult(res); else nextTurn();
    }
    cells.forEach((cell, idx)=> cell.addEventListener('click', () => handleMove(idx)));

    function resetBoard(hard=false){
      board = Array(9).fill(null);
      cells.forEach(c=>c.classList.remove('win'));
      players.X.cardEl.classList.remove('winner');
      players.O.cardEl.classList.remove('winner');
      gameOver = false;
      if(hard){ scoreX=0; scoreO=0; }
      current = xStarts ? 'X' : 'O';
      render();
      updateStatus(`Your turn: ${current} (${players[current].name})`);
      updateTurnUI();
      hideWinVideo();
    }
    function playAgain(){ xStarts=!xStarts; resetBoard(false); }
    function swapStarter(){ xStarts=!xStarts; current = xStarts ? 'X' : 'O'; updateStatus(`Starter swapped. ${players[current].name} (${current}) begins.`); updateTurnUI(); }

    btnReset.addEventListener('click', () => resetBoard(true));
    btnAgain.addEventListener('click', playAgain);
    btnSwap.addEventListener('click', swapStarter);

    document.addEventListener('keydown', (e)=>{
      if (gameOver) return;
      const k = e.key;
      if (/[1-9]/.test(k)){ handleMove(Number(k)-1); }
      else if (k==='r' || k==='R'){ playAgain(); }
    });

    function setWinnerBanner(symbol){
      const name = players[symbol].name;
      winnerBanner.textContent = `${name} Wins!`;
    }
    async function playWinVideo(symbol){
      setWinnerBanner(symbol);
      videoOverlay.classList.add('show');
      videoOverlay.setAttribute('aria-hidden','false');

      try { winVideo.pause(); } catch {}
      winVideo.loop = true;
      winVideo.muted = true;
      winVideo.removeAttribute('controls');
      winVideo.src = WIN_SRC;
      winVideo.currentTime = 0;
      winVideo.load();

      await Promise.race([ once(winVideo,'loadedmetadata'), once(winVideo,'canplay'), once(winVideo,'canplaythrough') ]);

      try {
        await winVideo.play();
        winVideo.muted = false;
      } catch {
        winVideo.muted = true;
        try { await winVideo.play(); } catch {}
      }
    }
    function hideWinVideo(){
      videoOverlay.classList.remove('show');
      videoOverlay.setAttribute('aria-hidden','true');
      try { winVideo.pause(); } catch {}
    }
    skipBtn.addEventListener('click', hideWinVideo);

    // Initial paint
    render();
    updateStatus(`Your turn: ${current} (${players[current].name})`);
    updateTurnUI();

    /***** Multiplayer over Firestore *****/
    // Schema: rooms/{roomId}
    // {
    //   board: [null|"X"|"O", ... 9],
    //   current: "X"|"O",
    //   xStarts: true|false,
    //   gameOver: true|false,
    //   scoreX: number, scoreO: number,
    //   updatedAt: serverTimestamp(),
    //   lastAction: { type: "move|reset|again|swap", idx?:number }
    // }

    const roomInput = document.getElementById('roomInput');
    const btnCreateRoom = document.getElementById('btnCreateRoom');
    const btnJoinRoom   = document.getElementById('btnJoinRoom');
    const btnCopyLink   = document.getElementById('btnCopyLink');

    let roomId = null;
    let roomDocRef = null;
    let unsubRoom = null;

    // read ?room= from URL
    const urlParams = new URLSearchParams(location.search);
    const initialRoomParam = urlParams.get('room');
    if (initialRoomParam) {
      roomInput.value = initialRoomParam;
      joinRoom(initialRoomParam);
    }

    btnCreateRoom.addEventListener('click', async () => {
      const rid = (roomInput.value || '').trim() || `room-${Math.random().toString(36).slice(2,8)}`;
      await createRoom(rid);
    });

    btnJoinRoom.addEventListener('click', async () => {
      const rid = (roomInput.value || '').trim();
      if (!rid) { alert('Enter a Room ID'); return; }
      await joinRoom(rid);
    });

    btnCopyLink.addEventListener('click', async () => {
      if (!roomId) { alert('Join or create a room first'); return; }
      const link = `${location.origin}${location.pathname}?room=${encodeURIComponent(roomId)}`;
      await navigator.clipboard.writeText(link);
      btnCopyLink.textContent = 'Copied!';
      setTimeout(()=>btnCopyLink.textContent='Copy Invite Link', 1200);
    });

    async function createRoom(rid){
      const ref = doc(db, 'rooms', rid);
      const exists = await getDoc(ref);
      if (exists.exists()) {
        alert('Room already exists. Joining instead.');
        return joinRoom(rid);
      }
      await setDoc(ref, {
        board: Array(9).fill(null),
        current: 'X',
        xStarts: true,
        gameOver: false,
        scoreX: 0, scoreO: 0,
        updatedAt: serverTimestamp(),
        lastAction: { type: 'init' }
      });
      return joinRoom(rid);
    }

    async function joinRoom(rid){
      // unsubscribe previous if any
      if (unsubRoom) { unsubRoom(); unsubRoom = null; }
      roomId = rid;
      roomDocRef = doc(db, 'rooms', roomId);

      const snap = await getDoc(roomDocRef);
      if (!snap.exists()){
        // If room not found, offer to create
        const ok = confirm('Room does not exist. Create it?');
        if (!ok) return;
        await createRoom(roomId);
        return;
      }

      // Sync local state from remote
      const data = snap.data();
      board    = data.board ?? Array(9).fill(null);
      current  = data.current ?? 'X';
      xStarts  = data.xStarts ?? true;
      gameOver = data.gameOver ?? false;
      scoreX   = data.scoreX ?? 0;
      scoreO   = data.scoreO ?? 0;
      render(); updateTurnUI(); updateStatus(`Room: ${roomId} · Your turn: ${current} (${players[current].name})`);

      // Listen for real-time updates
      unsubRoom = onSnapshot(roomDocRef, (docSnap)=>{
        if (!docSnap.exists()) return;
        const d = docSnap.data();

        // Apply remote -> local
        board    = d.board;
        current  = d.current;
        xStarts  = d.xStarts;
        gameOver = d.gameOver;
        scoreX   = d.scoreX;
        scoreO   = d.scoreO;

        // repaint
        render();
        cells.forEach(c=>c.classList.remove('win'));
        const res = checkWinner(); // re-highlight lines if ended
        updateTurnUI();
        updateStatus(`Room: ${roomId} · Your turn: ${current} (${players[current].name})`);

        // play video only if last action was a win and we just switched to gameOver
        if (d.lastAction?.type === 'move' && (res==='X' || res==='O')) {
          setTimeout(()=>playWinVideo(res), 50);
        }
      });

      // Push current URL with ?room=
      const url = new URL(location.href);
      url.searchParams.set('room', roomId);
      history.replaceState(null, '', url.toString());
    }

    // Multiplayer-aware handlers
    async function handleMove(idx){
      if (!roomDocRef) { // offline/local
        handleMoveLocal(idx);
        return;
      }
      // Transaction: ensure turn & empty cell before writing
      await runTransaction(db, async (tx)=>{
        const snap = await tx.get(roomDocRef);
        if (!snap.exists()) throw new Error('Room disappeared');
        const d = snap.data();
        if (d.gameOver) return;
        if (d.board[idx]) return;
        // Apply move
        const b = d.board.slice();
        b[idx] = d.current;

        // Determine win/draw
        const winner = checkWinnerOnBoard(b);
        let next = d.current === 'X' ? 'O' : 'X';
        let gameOverNew = false;
        let scoreXNew = d.scoreX, scoreONew = d.scoreO;

        if (winner === 'X'){ gameOverNew = true; scoreXNew++; }
        else if (winner === 'O'){ gameOverNew = true; scoreONew++; }
        else if (winner === 'Draw'){ gameOverNew = true; } // keep scores

        tx.update(roomDocRef, {
          board: b,
          current: gameOverNew ? d.current : next, // if ended, keep last player highlighted
          gameOver: gameOverNew,
          scoreX: scoreXNew, scoreO: scoreONew,
          updatedAt: serverTimestamp(),
          lastAction: { type:'move', idx }
        });
      });
    }
    function checkWinnerOnBoard(b){
      for(const [a,b1,c] of wins){
        if(b[a] && b[a]===b[b1] && b[a]===b[c]) return b[a];
      }
      if(b.every(x=>x)) return 'Draw';
      return null;
    }

    // Hook board clicks to multiplayer handler
    cells.forEach((cell, idx)=> cell.addEventListener('click', () => handleMove(idx)));

    // Sync control buttons
    btnReset.addEventListener('click', async ()=>{
      if (!roomDocRef) { resetBoard(true); return; }
      await updateDoc(roomDocRef, {
        board: Array(9).fill(null),
        current: 'X',
        xStarts: true,
        gameOver: false,
        scoreX: 0, scoreO: 0,
        updatedAt: serverTimestamp(),
        lastAction: { type:'reset' }
      });
    });
    btnAgain.addEventListener('click', async ()=>{
      if (!roomDocRef) { playAgain(); return; }
      // Toggle starter remotely
      await runTransaction(db, async(tx)=>{
        const s = await tx.get(roomDocRef); if(!s.exists()) return;
        const d = s.data();
        const xStartsNew = !d.xStarts;
        tx.update(roomDocRef, {
          board: Array(9).fill(null),
          gameOver: false,
          xStarts: xStartsNew,
          current: xStartsNew ? 'X' : 'O',
          updatedAt: serverTimestamp(),
          lastAction: { type:'again' }
        });
      });
    });
    btnSwap.addEventListener('click', async ()=>{
      if (!roomDocRef) { swapStarter(); return; }
      await runTransaction(db, async(tx)=>{
        const s = await tx.get(roomDocRef); if(!s.exists()) return;
        const d = s.data();
        const xStartsNew = !d.xStarts;
        tx.update(roomDocRef, {
          xStarts: xStartsNew,
          current: xStartsNew ? 'X' : 'O',
          updatedAt: serverTimestamp(),
          lastAction: { type:'swap' }
        });
      });
    });
  </script>
</body>
</html>
